-- 1. Table to log each individual video view event
CREATE TABLE IF NOT EXISTS public.individual_video_views (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_identifier TEXT NOT NULL,
    viewed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    country_code CHAR(2),
    viewer_session_id UUID, -- Client-generated UUID for "anonymous session"
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
    -- Removed user_id as we are focusing on fully anonymous
);

-- Add indexes if they don't exist
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_individual_views_video_identifier' AND n.nspname = 'public') THEN
    CREATE INDEX idx_individual_views_video_identifier ON public.individual_video_views(video_identifier);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_individual_views_viewed_at' AND n.nspname = 'public') THEN
    CREATE INDEX idx_individual_views_viewed_at ON public.individual_video_views(viewed_at);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_individual_views_country_code' AND n.nspname = 'public') THEN
    CREATE INDEX idx_individual_views_country_code ON public.individual_video_views(country_code);
END IF; END $$;

-- Enable RLS on individual_video_views if not already enabled
DO $$ BEGIN IF NOT (SELECT relrowsecurity FROM pg_class WHERE relname = 'individual_video_views' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
    ALTER TABLE public.individual_video_views ENABLE ROW LEVEL SECURITY;
END IF; END $$;

-- RLS Policy: Allow service_role (e.g., from Edge Function) to manage these.
DROP POLICY IF EXISTS "Allow service_role to manage individual views" ON public.individual_video_views;
CREATE POLICY "Allow service_role to manage individual views"
ON public.individual_video_views
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);


-- 2. Table to store video likes (for anonymous users)
CREATE TABLE IF NOT EXISTS public.video_likes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_identifier TEXT NOT NULL,
    anonymous_session_id UUID NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT unique_anonymous_video_identifier_like UNIQUE (video_identifier, anonymous_session_id)
);

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_video_likes_video_identifier_anon' AND n.nspname = 'public') THEN
    CREATE INDEX idx_video_likes_video_identifier_anon ON public.video_likes(video_identifier);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_video_likes_anon_session_id' AND n.nspname = 'public') THEN
    CREATE INDEX idx_video_likes_anon_session_id ON public.video_likes(anonymous_session_id);
END IF; END $$;


DO $$ BEGIN IF NOT (SELECT relrowsecurity FROM pg_class WHERE relname = 'video_likes' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
    ALTER TABLE public.video_likes ENABLE ROW LEVEL SECURITY;
END IF; END $$;

DROP POLICY IF EXISTS "Allow public read access to likes" ON public.video_likes;
CREATE POLICY "Allow public read access to likes"
ON public.video_likes
FOR SELECT
TO anon, authenticated
USING (true);

-- 3. Table for hourly views by country (aggregation from individual_video_views)
CREATE TABLE IF NOT EXISTS public.hourly_video_views_by_country (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_identifier TEXT NOT NULL,
    country_code CHAR(2) NOT NULL,
    view_hour TIMESTAMPTZ NOT NULL,
    view_count INT DEFAULT 0 NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT unique_hourly_video_country_view UNIQUE (video_identifier, country_code, view_hour)
);

DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_hourly_views_video_identifier' AND n.nspname = 'public') THEN
    CREATE INDEX idx_hourly_views_video_identifier ON public.hourly_video_views_by_country(video_identifier);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_hourly_views_country_code' AND n.nspname = 'public') THEN
    CREATE INDEX idx_hourly_views_country_code ON public.hourly_video_views_by_country(country_code);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_hourly_views_view_hour' AND n.nspname = 'public') THEN
    CREATE INDEX idx_hourly_views_view_hour ON public.hourly_video_views_by_country(view_hour);
END IF; END $$;

DO $$ BEGIN IF NOT (SELECT relrowsecurity FROM pg_class WHERE relname = 'hourly_video_views_by_country' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
    ALTER TABLE public.hourly_video_views_by_country ENABLE ROW LEVEL SECURITY;
END IF; END $$;

DROP POLICY IF EXISTS "Allow public read access to hourly view stats" ON public.hourly_video_views_by_country;
CREATE POLICY "Allow public read access to hourly view stats"
ON public.hourly_video_views_by_country
FOR SELECT
TO anon, authenticated
USING (true);

-- Trigger function to update 'updated_at' (if not already existing globally from a previous migration)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_updated_at_column' AND pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        CREATE OR REPLACE FUNCTION public.update_updated_at_column()
        RETURNS TRIGGER AS $func$
        BEGIN
           NEW.updated_at = NOW();
           RETURN NEW;
        END;
        $func$ LANGUAGE plpgsql;
    END IF;
END $$;

-- Apply trigger to hourly_video_views_by_country if not already applied
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_hourly_video_views_by_country_updated_at') THEN
    CREATE TRIGGER set_hourly_video_views_by_country_updated_at
    BEFORE UPDATE ON public.hourly_video_views_by_country
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
END IF; END $$;


-- 4. NEW Table: Donations
CREATE TABLE IF NOT EXISTS public.donations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    video_identifier TEXT, -- Optional: if donation is for a specific video
    donor_name TEXT,       -- Optional
    donation_amount DECIMAL(10, 2) NOT NULL, -- Example: 12345.67
    currency CHAR(3) NOT NULL DEFAULT 'EUR', -- ISO 4217 currency code
    donor_message TEXT,    -- Optional
    country_code CHAR(2),  -- Optional: country of the donor
    payment_processor TEXT, -- e.g., 'paypal', 'revolut', 'stripe'
    transaction_id TEXT,   -- Optional: ID from the payment processor for reference
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    anonymous_session_id UUID -- Optional: if an anonymous user (who might have also liked) makes a donation
    -- You could also add a user_id UUID REFERENCES auth.users(id) if you later add user accounts
);

-- Add indexes for donations table
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_donations_video_identifier' AND n.nspname = 'public') THEN
    CREATE INDEX idx_donations_video_identifier ON public.donations(video_identifier);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_donations_created_at' AND n.nspname = 'public') THEN
    CREATE INDEX idx_donations_created_at ON public.donations(created_at);
END IF; END $$;
DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = 'idx_donations_payment_processor' AND n.nspname = 'public') THEN
    CREATE INDEX idx_donations_payment_processor ON public.donations(payment_processor);
END IF; END $$;


DO $$ BEGIN IF NOT (SELECT relrowsecurity FROM pg_class WHERE relname = 'donations' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
    ALTER TABLE public.donations ENABLE ROW LEVEL SECURITY;
END IF; END $$;

-- RLS Policies for Donations:
-- Insertions should ideally happen via a secure Edge Function after payment confirmation.
DROP POLICY IF EXISTS "Allow service_role to insert donations" ON public.donations;
CREATE POLICY "Allow service_role to insert donations"
ON public.donations
FOR INSERT
WITH CHECK (true); -- For service_role key

-- Public read access to donations (e.g., to show a list of recent donations, perhaps anonymized)
-- Be careful about what information you make public.
DROP POLICY IF EXISTS "Allow public read of non-sensitive donation info" ON public.donations;
CREATE POLICY "Allow public read of non-sensitive donation info"
ON public.donations
FOR SELECT
TO anon, authenticated
USING (true); -- Consider creating a VIEW that exposes only safe-to-display fields.


-- 5. Your existing video_views table (for total counts, based on your image)
-- Assuming it exists and has columns: id UUID, created_at TIMESTAMPTZ, video_identifier TEXT UNIQUE, view_count BIGINT, updated_at TIMESTAMPTZ
DO $$ BEGIN IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'video_views') THEN
    IF NOT (SELECT relrowsecurity FROM pg_class WHERE relname = 'video_views' AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
        ALTER TABLE public.video_views ENABLE ROW LEVEL SECURITY;
    END IF;

    DROP POLICY IF EXISTS "Allow public read access to total video views" ON public.video_views;
    CREATE POLICY "Allow public read access to total video views"
    ON public.video_views
    FOR SELECT
    TO anon, authenticated
    USING (true);

    -- Ensure update_updated_at_column trigger is on video_views if it makes sense for your setup
    -- (e.g., if view_count is updated directly on this table)
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'set_video_views_updated_at' AND tgrelid = 'public.video_views'::regclass) THEN
        CREATE TRIGGER set_video_views_updated_at
        BEFORE UPDATE ON public.video_views
        FOR EACH ROW
        WHEN (OLD.view_count IS DISTINCT FROM NEW.view_count) -- Only if view_count changes
        EXECUTE FUNCTION public.update_updated_at_column();
    END IF;

END IF; END $$;

-- Note on populating `hourly_video_views_by_country`:
-- This still requires a scheduled function (e.g., Supabase Cron Job + Edge Function)
-- to aggregate data from `individual_video_views`.

-- Note on populating `donations`:
-- This table would typically be populated by a webhook from your payment processor (PayPal, Revolut)
-- or by an Edge Function called after a successful client-side donation flow.